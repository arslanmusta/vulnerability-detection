package cve.vulnerabilityservice.task;

import cve.vulnerabilityservice.domain.Cpe;
import cve.vulnerabilityservice.domain.CpeMatch;
import cve.vulnerabilityservice.domain.Cve;
import cve.vulnerabilityservice.domain.Source;
import cve.vulnerabilityservice.proxy.cpe.CpeProxy;
import cve.vulnerabilityservice.proxy.cpe.model.Cpe23Item;
import cve.vulnerabilityservice.proxy.cpe.model.CpeResponse;
import cve.vulnerabilityservice.proxy.cpematch.CpeMatchProxy;
import cve.vulnerabilityservice.proxy.cpematch.model.CpeMatchResponse;
import cve.vulnerabilityservice.proxy.cve.CveProxy;
import cve.vulnerabilityservice.proxy.cve.implementation.CveProxyImpl;
import cve.vulnerabilityservice.proxy.cve.model.CveResponse;
import cve.vulnerabilityservice.repository.CpeMatchRepository;
import cve.vulnerabilityservice.repository.CpeRepository;
import cve.vulnerabilityservice.repository.CveRepository;
import cve.vulnerabilityservice.repository.SourceRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.sql.Timestamp;
import java.time.Instant;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Component
public class DatabaseUpdateTask {
    private static final Logger log = LoggerFactory.getLogger(CveProxyImpl.class);
    private final CveProxy cveProxy;
    private final CpeProxy cpeProxy;
    private final CpeMatchProxy cpeMatchProxy;
    private final CpeRepository cpeRepository;
    private final CpeMatchRepository cpeMatchRepository;
    private final CveRepository cveRepository;
    private final SourceRepository sourceRepository;

    @Value("${cve.update.timeout}")
    private long cveUpdateTimout;

    public DatabaseUpdateTask(CveProxy cveProxy, CpeProxy cpeProxy, CpeMatchProxy cpeMatchProxy, CpeRepository cpeRepository, CpeMatchRepository cpeMatchRepository, CveRepository cveRepository, SourceRepository sourceRepository) {
        this.cveProxy = cveProxy;
        this.cpeProxy = cpeProxy;
        this.cpeMatchProxy = cpeMatchProxy;
        this.cpeRepository = cpeRepository;
        this.cpeMatchRepository = cpeMatchRepository;
        this.cveRepository = cveRepository;
        this.sourceRepository = sourceRepository;
    }

    @Scheduled(fixedDelayString = "${cve.update.period}")

    public void update() {
        // TODO: update on per 24 hour for modified source
        // TODO: check RUNNING state is so long
        Source cpeSource = sourceRepository.findFirstByTypeAndStateAndLastUpdateLessThan('P', "IDLE", Timestamp.from(Instant.now().minusSeconds(cveUpdateTimout))).orElse(null);
        if (cpeSource != null) {
            cpeSource.setState("RUNNING");
            sourceRepository.save(cpeSource);

            updateCpe(cpeSource.getUrl());

            cpeSource.setLastUpdate(Timestamp.from(Instant.now()));
            cpeSource.setState("IDLE");
            sourceRepository.save(cpeSource);
        }

        Source cpeMatchSource = sourceRepository.findFirstByTypeAndStateAndLastUpdateLessThan('M', "IDLE", Timestamp.from(Instant.now().minusSeconds(cveUpdateTimout))).orElse(null);
        if (cpeMatchSource != null) {
            cpeMatchSource.setState("RUNNING");
            sourceRepository.save(cpeMatchSource);

            updateCpeMatch(cpeMatchSource.getUrl());

            cpeMatchSource.setLastUpdate(Timestamp.from(Instant.now()));
            cpeMatchSource.setState("IDLE");
            sourceRepository.save(cpeMatchSource);
        }

        Source cveSource = sourceRepository.findFirstByTypeAndStateAndLastUpdateLessThan('V', "IDLE", Timestamp.from(Instant.now().minusSeconds(cveUpdateTimout))).orElse(null);

        while (cveSource != null) {
            cveSource.setState("RUNNING");
            sourceRepository.save(cveSource);

            updateCve(cveSource.getUrl());

            cveSource.setLastUpdate(Timestamp.from(Instant.now()));
            cveSource.setState("IDLE");
            sourceRepository.save(cveSource);

            cveSource = sourceRepository.findFirstByTypeAndStateAndLastUpdateLessThan('V', "IDLE", Timestamp.from(Instant.now().minusSeconds(cveUpdateTimout))).orElse(null);
        }

        Source modifiedCveSource = sourceRepository.findFirstByTypeAndStateAndLastUpdateLessThan('U', "IDLE", Timestamp.from(Instant.now().minusSeconds(cveUpdateTimout))).orElse(null);

        if (modifiedCveSource != null) {
            modifiedCveSource.setState("RUNNING");
            sourceRepository.save(modifiedCveSource);

            updateCve(modifiedCveSource.getUrl());

            modifiedCveSource.setLastUpdate(Timestamp.from(Instant.now()));
            modifiedCveSource.setState("IDLE");
            sourceRepository.save(modifiedCveSource);
        }
        
    }

    private void updateCpe(String url) {
        log.info("Calling " + url);

        CpeResponse cpeResponse = cpeProxy.GetCpe(url);

        log.info("Processing data for " + url);

        List<Cpe> cpeList = cpeResponse.getCpeItems().parallelStream().map(cpeItem -> {
            if(!cpeItem.isDeprecated()) {
                Cpe23Item cpe23Item = cpeItem.getCpe23item();

                Cpe cpe = cpeRepository.findByName(cpe23Item.getName()).orElse(null);
                if(cpe == null) {
                    String[] cpeNameColons = cpe23Item.getName().split(":");

                    cpe = new Cpe();

                    cpe.setName(cpe23Item.getName());
                    cpe.setPart(cpeNameColons[2].charAt(0));
                    cpe.setVendor(cpeNameColons[3]);
                    cpe.setProduct(cpeNameColons[4]);
                    cpe.setVersion(cpeNameColons[5]);
                    cpe.setUpdate(cpeNameColons[6]);
                    cpe.setEdition(cpeNameColons[7]);
                    cpe.setLanguage(cpeNameColons[8]);
                    cpe.setSoftwareEdition(cpeNameColons[9]);
                    cpe.setTargetSoftware(cpeNameColons[10]);
                    cpe.setTargetHardware(cpeNameColons[11]);
                    cpe.setOther(cpeNameColons[12]);

                    return cpe;
                }
            }
            return null;
        }).filter(Objects::nonNull).toList();

        log.info("Updating database for " + url);

        cpeRepository.saveAll(cpeList);

        log.info("Update completed for " + url);
    }

    private void updateCpeMatch(String url) {
        log.info("Calling " + url);

        CpeMatchResponse cpeMatchResponse = cpeMatchProxy.GetCpeMatch(url);

        log.info("Processing data for " + url);

        List<CpeMatch> cpeMatchList = cpeMatchResponse.getMatches().parallelStream().map(cpeMatchModel -> {
            CpeMatch cpeMatch = new CpeMatch();

            cpeMatch.setName(cpeMatchModel.getCpe23Uri());
            cpeMatch.setVersionStartIncluding(cpeMatchModel.getVersionStartIncluding());
            cpeMatch.setVersionStartExcluding(cpeMatchModel.getVersionStartExcluding());
            cpeMatch.setVersionEndIncluding(cpeMatchModel.getVersionEndIncluding());
            cpeMatch.setVersionEndExcluding(cpeMatchModel.getVersionEndExcluding());
            cpeMatch.setVulnerable(cpeMatchModel.isVulnerable());

            Set<Cpe> cpeSet = cpeMatchModel.getCpeNames().stream().map(cpeName -> cpeRepository.findByName(cpeName.getCpe23Uri()).orElse(null)).collect(Collectors.toSet());

            cpeMatch.setCpeSet(cpeSet);

            return cpeMatch;
        }).toList();

        log.info("Updating database for " + url);

        cpeMatchRepository.saveAll(cpeMatchList);

        log.info("Update completed for " + url);
    }

    private void updateCve(String url) {
        log.info("Calling " + url);

        CveResponse cveResponse = cveProxy.GetCve(url);

        log.info("Processing data for " + url);

        List<Cve> cveList = cveResponse.getCveItems().parallelStream().map(cveItem -> {
            Cve cve = new Cve();

            cve.setId(cveItem.getCve().getCveDataMeta().getId());
            cve.setSummary(cveItem.getCve().getDescription().getDescriptionData().get(0).getValue());

            if (cveItem.getImpact().getBaseMetricV3() != null) {
                cve.setCvss3(cveItem.getImpact().getBaseMetricV3().getCvssV3().getBaseScore());
            }

            if (cveItem.getImpact().getBaseMetricV2() != null) {
                cve.setCvss3(cveItem.getImpact().getBaseMetricV2().getCvssV2().getBaseScore());
            }

            Set<CpeMatch> cpeMatchSet = cveItem.getConfigurations().getNodes().parallelStream().map(node -> {
                if (Objects.equals(node.getOperator(), "OR")) {
                    return node.getCpeMatches().stream().map(cpeMatchModel -> cpeMatchRepository.findByNameAndVersionStartIncludingAndVersionStartExcludingAndVersionEndIncludingAndVersionEndExcluding(
                            cpeMatchModel.getCpe23Uri(),
                            cpeMatchModel.getVersionStartIncluding(),
                            cpeMatchModel.getVersionStartExcluding(),
                            cpeMatchModel.getVersionEndIncluding(),
                            cpeMatchModel.getVersionEndExcluding()
                    ).orElse(null)).filter(Objects::nonNull).toList();
                }
                else {
                    return node.getChildren().stream().map(childNode -> childNode.getCpeMatches().stream().filter(cpeMatchModel -> cpeMatchModel.isVulnerable()).map(cpeMatchModel -> cpeMatchRepository.findByNameAndVersionStartIncludingAndVersionStartExcludingAndVersionEndIncludingAndVersionEndExcluding(
                            cpeMatchModel.getCpe23Uri(),
                            cpeMatchModel.getVersionStartIncluding(),
                            cpeMatchModel.getVersionStartExcluding(),
                            cpeMatchModel.getVersionEndIncluding(),
                            cpeMatchModel.getVersionEndExcluding()
                    ).orElse(null)).filter(Objects::nonNull).toList()).flatMap(List::stream).toList();
                }
            }).flatMap(List::stream).collect(Collectors.toSet());

            cve.setCpeMatchSet(cpeMatchSet);

            return cve;

        }).toList();

        log.info("Updating database for " + url);

        cveRepository.saveAll(cveList);

        log.info("Update completed for " + url);

    }
}
